from flask import Flask, render_template, request, redirect, url_for, session, jsonify, flash
import json
import os
from db import get_db, init_db
from sample_data import ensure_sample_data
from matcher import evaluate_rules_for_profile

app = Flask(__name__)
app.secret_key = 'dev-secret-for-demo'  # change in production
DB_PATH = os.path.join(os.path.dirname(__file__), 'schemes.db')

# Initialize DB and sample data
init_db(DB_PATH)
ensure_sample_data(DB_PATH)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/match', methods=['POST'])
def match():
    profile = {
        'age': int(request.form.get('age') or 0),
        'income': float(request.form.get('income') or 0),
        'gender': request.form.get('gender') or '',
        'state': request.form.get('state') or '',
        'occupation': request.form.get('occupation') or '',
        'caste': request.form.get('caste') or '',
        'disability': request.form.get('disability') or 'no',
        'household_size': int(request.form.get('household_size') or 1)
    }
    # call matcher which returns list of results
    results = evaluate_rules_for_profile(DB_PATH, profile)
    # store in session briefly to show results page
    session['last_results'] = results
    session['profile'] = profile
    return redirect(url_for('results'))

@app.route('/results')
def results():
    results = session.get('last_results', [])
    profile = session.get('profile', {})
    return render_template('results.html', results=results, profile=profile)

@app.route('/scheme/<int:scheme_id>')
def scheme_detail(scheme_id):
    db = get_db(DB_PATH)
    cur = db.cursor()
    cur.execute('SELECT id, title, description, source_url FROM schemes WHERE id=?', (scheme_id,))
    row = cur.fetchone()
    if not row:
        return 'Scheme not found', 404
    cur.execute('SELECT id, rule_json, snippet, parser_confidence FROM scheme_rules WHERE scheme_id=?', (scheme_id,))
    rule = cur.fetchone()
    rule_json = rule[1] if rule else None
    snippet = rule[2] if rule else ''
    confidence = rule[3] if rule else None
    profile = session.get('profile')
    evaluation = None
    if profile and rule_json:
        try:
            rule_obj = json.loads(rule_json)
            # simple local evaluation using matcher evaluate
            from matcher import evaluate_rule
            ok = evaluate_rule(rule_obj, profile)
            evaluation = { 'eligible': ok }
        except Exception as e:
            evaluation = { 'error': str(e) }
    return render_template('scheme.html', scheme={'id':row[0],'title':row[1],'description':row[2],'source_url':row[3]}, snippet=snippet, rule_json=rule_json, confidence=confidence, evaluation=evaluation)

# ---------------- Admin ----------------
@app.route('/admin/login', methods=['GET','POST'])
def admin_login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        if username == 'admin' and password == 'password':
            session['admin'] = True
            return redirect(url_for('admin_dashboard'))
        else:
            flash('Invalid credentials')
    return render_template('admin_login.html')

@app.route('/admin/logout')
def admin_logout():
    session.pop('admin', None)
    return redirect(url_for('index'))

@app.route('/admin')
def admin_dashboard():
    if not session.get('admin'):
        return redirect(url_for('admin_login'))
    db = get_db(DB_PATH)
    cur = db.cursor()
    cur.execute('SELECT s.id, s.title, sr.parser_confidence, sr.id IS NOT NULL as has_rule FROM schemes s LEFT JOIN scheme_rules sr ON s.id=sr.scheme_id')
    rows = cur.fetchall()
    schemes = []
    for r in rows:
        schemes.append({'id': r[0], 'title': r[1], 'confidence': r[2], 'has_rule': bool(r[3])})
    return render_template('admin_dashboard.html', schemes=schemes)

@app.route('/admin/verify/<int:scheme_id>', methods=['GET','POST'])
def admin_verify(scheme_id):
    if not session.get('admin'):
        return redirect(url_for('admin_login'))
    db = get_db(DB_PATH)
    cur = db.cursor()
    cur.execute('SELECT id, title FROM schemes WHERE id=?', (scheme_id,))
    s = cur.fetchone()
    if not s:
        return 'Scheme not found', 404
    if request.method == 'POST':
        rule_json = request.form.get('rule_json')
        snippet = request.form.get('snippet')
        try:
            # validate JSON
            parsed = json.loads(rule_json)
        except Exception as e:
            flash('Invalid JSON: ' + str(e))
            return redirect(url_for('admin_verify', scheme_id=scheme_id))
        # upsert
        cur.execute('SELECT id FROM scheme_rules WHERE scheme_id=?', (scheme_id,))
        existing = cur.fetchone()
        if existing:
            cur.execute('UPDATE scheme_rules SET rule_json=?, snippet=?, parser_confidence=? WHERE scheme_id=?', (rule_json, snippet, 1.0, scheme_id))
        else:
            cur.execute('INSERT INTO scheme_rules (scheme_id, rule_json, snippet, parser_confidence) VALUES (?,?,?,?)', (scheme_id, rule_json, snippet, 1.0))
        db.commit()
        flash('Saved')
        return redirect(url_for('admin_dashboard'))
    else:
        cur.execute('SELECT sr.rule_json, sr.snippet, sr.parser_confidence FROM scheme_rules sr WHERE sr.scheme_id=?', (scheme_id,))
        r = cur.fetchone()
        rule_json = r[0] if r else json.dumps({'all': []}, indent=2)
        snippet = r[1] if r else 'No snippet available (dummy data)'
        return render_template('admin_verify.html', scheme={'id':s[0],'title':s[1]}, rule_json=rule_json, snippet=snippet)

# ---------------- Analytics APIs ----------------
@app.route('/api/stats/schemes_by_state')
def stats_schemes_by_state():
    db = get_db(DB_PATH)
    cur = db.cursor()
    cur.execute('SELECT state, COUNT(*) FROM schemes GROUP BY state')
    rows = cur.fetchall()
    return jsonify([{ 'state': r[0] or 'Unknown', 'count': r[1]} for r in rows])

@app.route('/api/scheme/<int:scheme_id>')
def api_scheme(scheme_id):
    db = get_db(DB_PATH)
    cur = db.cursor()
    cur.execute('SELECT id, title, description, source_url FROM schemes WHERE id=?', (scheme_id,))
    r = cur.fetchone()
    if not r:
        return jsonify({'error':'not found'}), 404
    cur.execute('SELECT rule_json, snippet, parser_confidence FROM scheme_rules WHERE scheme_id=?', (scheme_id,))
    s = cur.fetchone()
    return jsonify({ 'id': r[0], 'title': r[1], 'description': r[2], 'source_url': r[3], 'rule': json.loads(s[0]) if s else None, 'snippet': s[1] if s else None, 'confidence': s[2] if s else None })

if __name__ == '__main__':
    app.run(debug=True)
import sqlite3
import os

def get_db(db_path):
    conn = sqlite3.connect(db_path, check_same_thread=False)
    return conn


def init_db(db_path):
    if not os.path.exists(db_path):
        conn = sqlite3.connect(db_path)
        cur = conn.cursor()
        cur.execute('''
        CREATE TABLE schemes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT,
            description TEXT,
            state TEXT,
            source_url TEXT
        )
        ''')
        cur.execute('''
        CREATE TABLE scheme_rules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            scheme_id INTEGER,
            rule_json TEXT,
            snippet TEXT,
            parser_confidence REAL,
            FOREIGN KEY(scheme_id) REFERENCES schemes(id)
        )
        ''')
        conn.commit()
        conn.close()import sqlite3
import json

# Basic evaluator for our rule JSON structure

def evaluate_rule(rule, profile):
    """Return True/False for atomic rule JSON. Supports 'all' and 'any' and atomic ops."""
    if rule is None:
        return False
    if 'all' in rule:
        return all(evaluate_rule(r, profile) for r in rule['all'])
    if 'any' in rule:
        return any(evaluate_rule(r, profile) for r in rule['any'])
    # atomic
    field = rule.get('field')
    op = rule.get('op')
    value = rule.get('value')
    user_val = profile.get(field)
    # normalize
    if user_val is None:
        return False
    # numeric comparisons
    if op in ['<','<=','>','>=']:
        try:
            uv = float(user_val)
            vv = float(value)
        except:
            return False
        if op == '<': return uv < vv
        if op == '<=': return uv <= vv
        if op == '>': return uv > vv
        if op == '>=': return uv >= vv
    if op == '==':
        return str(user_val).lower() == str(value).lower()
    if op == 'in':
        # value expected list
        return str(user_val).lower() in [str(v).lower() for v in value]
    return False


def evaluate_rules_for_profile(db_path, profile):
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute('SELECT s.id, s.title, s.description, sr.rule_json, sr.snippet, sr.parser_confidence FROM schemes s LEFT JOIN scheme_rules sr ON s.id=sr.scheme_id')
    rows = cur.fetchall()
    results = []
    for r in rows:
        scheme_id = r[0]
        title = r[1]
        desc = r[2]
        rule_json = r[3]
        snippet = r[4]
        conf = r[5]
        passed = False
        score = 0.0
        reasons = {}
        if rule_json:
            try:
                rule_obj = json.loads(rule_json)
                passed = evaluate_rule(rule_obj, profile)
                score = 1.0 if passed else 0.0
                reasons = {'snippet': snippet}
            except Exception as e:
                reasons = {'error': str(e)}
        else:
            reasons = {'note': 'No rule available'}
        results.append({
            'scheme_id': scheme_id,
            'title': title,
            'description': desc,
            'result': 'eligible' if passed else 'not eligible',
            'score': score,
            'reasons': reasons
        })
    conn.close()
    # sort eligible first
    results = sorted(results, key=lambda x: (-x['score'], x['title']))
    return results
#models.py
from db import db
from datetime import datetime
import json

class Scheme(db.Model):
    __tablename__ = "schemes"
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String, nullable=False)
    description = db.Column(db.Text)
    source_url = db.Column(db.String)
    last_scraped = db.Column(db.DateTime)
    raw_html_path = db.Column(db.String)

    def to_dict(self):
        return {
            "id": self.id, "title": self.title, "description": self.description,
            "source_url": self.source_url, "last_scraped": self.last_scraped.isoformat() if self.last_scraped else None
        }

class SchemeRule(db.Model):
    __tablename__ = "scheme_rules"
    id = db.Column(db.Integer, primary_key=True)
    scheme_id = db.Column(db.Integer, db.ForeignKey("schemes.id"), nullable=False)
    rule_json = db.Column(db.JSON)
    snippet = db.Column(db.Text)
    parser_confidence = db.Column(db.Float, default=0.0)
    verified = db.Column(db.Boolean, default=False)

class UserProfile(db.Model):
    __tablename__ = "users"
    id = db.Column(db.Integer, primary_key=True)
    created = db.Column(db.DateTime, default=datetime.utcnow)
    profile = db.Column(db.JSON)   # store the submitted profile JSON

class MatchResult(db.Model):
    __tablename__ = "matches"
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"))
    scheme_id = db.Column(db.Integer, db.ForeignKey("schemes.id"))
    result = db.Column(db.String)   # eligible/maybe/not
    score = db.Column(db.Float)
    reasons = db.Column(db.JSON)
    created = db.Column(db.DateTime, default=datetime.utcnow)
# routes.py
import os
import json
import traceback
from functools import wraps
from flask import (
    request, jsonify, render_template, redirect, url_for,
    abort, current_app
)

from app import app
from db import db
from models import Scheme, SchemeRule, UserProfile, MatchResult

# ------------------------------------------------------------------
# Matcher integration: try direct python import first, else HTTP call
# Person B should expose a function: match_profile(profile: dict) -> list[dict]
# Each dict: {"scheme_id": int, "result": "eligible"/"maybe"/"not", "score": float, "reasons": {...}}
# ------------------------------------------------------------------
MATCHER_TYPE = "none"
match_profile = None

try:
    # try direct import (preferred)
    from matcher.engine import match_profile as match_profile_py  # adjust path if needed
    match_profile = match_profile_py
    MATCHER_TYPE = "python"
    app.logger.info("Matcher integrated: python import")
except Exception:
    # fallback to HTTP
    MATCHER_HTTP_URL = os.getenv("MATCHER_HTTP_URL", "http://localhost:8000/match")
    MATCHER_TYPE = "http"
    app.logger.info("Matcher not available via python import; will use HTTP at %s", MATCHER_HTTP_URL)


# ------------------------------------------------------------------
# Basic admin auth decorator (very small, env-configured)
# Use ADMIN_USER and ADMIN_PASS environment variables.
# For production, replace with proper auth!
# ------------------------------------------------------------------
def check_admin_auth(username, password):
    return username == os.getenv("ADMIN_USER", "admin") and password == os.getenv("ADMIN_PASS", "password")


def require_admin(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_admin_auth(auth.username, auth.password):
            return current_app.make_response(('Could not verify your access level for that URL.\n'
                                              'You have to login with proper credentials', 401,
                                              {'WWW-Authenticate': 'Basic realm="Login Required"'}))
        return f(*args, **kwargs)
    return decorated


# ------------------------------------------------------------------
# Landing page
# ------------------------------------------------------------------
@app.route("/", methods=["GET"])
def index():
    return render_template("index.html") if os.path.exists(os.path.join(app.root_path, "templates", "index.html")) else "Gov Schemes - Home"


# ------------------------------------------------------------------
# Simple profile input page (Jinja form) - client-side JS posts to /api/match
# ------------------------------------------------------------------
@app.route("/match", methods=["GET"])
def match_form():
    # If template exists, render it. Else show a minimal HTML form
    template_path = os.path.join(app.root_path, "templates", "match_form.html")
    if os.path.exists(template_path):
        return render_template("match_form.html")
    return """
    <h2>Profile Input</h2>
    <form id="p">
      Age: <input name="age"><br>
      Income: <input name="income"><br>
      Gender: <input name="gender"><br>
      State: <input name="state"><br>
      Occupation: <input name="occupation"><br>
      <button type="submit">Submit</button>
    </form>
    <pre id="out"></pre>
    <script>
    document.getElementById('p').onsubmit = async e => {
      e.preventDefault();
      const f = e.target;
      const data = {
        age: Number(f.age.value) || null,
        income: Number(f.income.value) || null,
        gender: f.gender.value || null,
        state: f.state.value || null,
        occupation: f.occupation.value || null
      };
      const res = await fetch('/api/match', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data)});
      const j = await res.json();
      document.getElementById('out').innerText = JSON.stringify(j, null, 2);
    };
    </script>
    """


# ------------------------------------------------------------------
# API: get scheme details + its parsed rules
# ------------------------------------------------------------------
@app.route("/api/scheme/<int:scheme_id>", methods=["GET"])
def api_scheme(scheme_id):
    scheme = Scheme.query.get_or_404(scheme_id)
    rules = SchemeRule.query.filter_by(scheme_id=scheme_id).all()
    return jsonify({
        "scheme": scheme.to_dict() if hasattr(scheme, "to_dict") else {
            "id": scheme.id, "title": scheme.title, "description": scheme.description, "source_url": scheme.source_url
        },
        "rules": [
            {
                "id": r.id,
                "rule_json": r.rule_json,
                "snippet": r.snippet,
                "parser_confidence": r.parser_confidence,
                "verified": r.verified
            } for r in rules
        ]
    })


# ------------------------------------------------------------------
# API: run matching for a profile
# - saves user profile into users table
# - persists match results into matches
# ------------------------------------------------------------------
@app.route("/api/match", methods=["POST"])
def api_match():
    try:
        profile = request.get_json(silent=True)
        if not profile or not isinstance(profile, dict):
            return jsonify({"error": "Profile JSON required"}), 400

        # Save user profile
        user = UserProfile(profile=profile)
        db.session.add(user)
        db.session.commit()

        # Call matcher
        results = []
        if MATCHER_TYPE == "python" and match_profile:
            try:
                results = match_profile(profile)
            except Exception as e:
                app.logger.exception("Matcher (python) failed: %s", e)
                return jsonify({"error": "Internal matcher error", "detail": str(e)}), 500
        else:
            # HTTP fallback
            TRY_URL = os.getenv("MATCHER_HTTP_URL", "http://localhost:8000/match")
            try:
                import requests
                resp = requests.post(TRY_URL, json=profile, timeout=15)
                resp.raise_for_status()
                results = resp.json()
            except Exception as e:
                app.logger.exception("Matcher (http) failed: %s", e)
                # As a fallback, return empty results (or stub) but keep user saved
                # You may prefer to return 500 instead.
                return jsonify({"error": "Matcher service unavailable", "detail": str(e)}), 502

        # Validate results format (basic)
        if not isinstance(results, list):
            return jsonify({"error": "Invalid matcher response format"}), 502

        # Persist match results
        saved = []
        for r in results:
            try:
                scheme_id = int(r.get("scheme_id"))
                result_label = r.get("result", "not")
                score = r.get("score")
                reasons = r.get("reasons", {})
                mr = MatchResult(user_id=user.id, scheme_id=scheme_id, result=result_label, score=score, reasons=reasons)
                db.session.add(mr)
                saved.append({
                    "scheme_id": scheme_id,
                    "result": result_label,
                    "score": score,
                    "reasons": reasons
                })
            except Exception:
                app.logger.exception("Failed saving match result: %s", r)
        db.session.commit()

        return jsonify({"user_id": user.id, "results": saved}), 200

    except Exception as e:
        app.logger.exception("Unhandled /api/match error")
        return jsonify({"error": "Internal server error", "detail": str(e)}), 500


# ------------------------------------------------------------------
# Example analytics endpoint: schemes grouped by source_url (demonstration)
# Adapt to your actual 'state' column or extraction
# ------------------------------------------------------------------
@app.route("/api/stats/schemes_by_state", methods=["GET"])
def stats_schemes_by_state():
    try:
        # Example: if schemes store state in raw_html_path or description, you'd adapt this.
        # Here we group by source_url as a placeholder.
        from sqlalchemy import func
        rows = db.session.query(Scheme.source_url, func.count(Scheme.id)).group_by(Scheme.source_url).all()
        return jsonify([{"source_url": r[0], "count": r[1]} for r in rows])
    except Exception as e:
        app.logger.exception("Error computing stats")
        return jsonify({"error": "Failed to compute stats", "detail": str(e)}), 500


# ------------------------------------------------------------------
# ADMIN UI: list unverified/low-confidence rules
# ------------------------------------------------------------------
@app.route("/admin", methods=["GET"])
@require_admin
def admin_index():
    try:
        pending = SchemeRule.query.filter_by(verified=False).order_by(SchemeRule.parser_confidence.asc()).limit(200).all()
        # If template exists, render it
        template_path = os.path.join(app.root_path, "templates", "admin_index.html")
        if os.path.exists(template_path):
            return render_template("admin_index.html", pending=pending)
        # Minimal HTML fallback
        html = "<h1>Admin - Pending Rules</h1><ul>"
        for r in pending:
            html += f"<li>Rule #{r.id} (scheme={r.scheme_id}) - confidence={r.parser_confidence} - <a href='{url_for('admin_verify', rule_id=r.id)}'>verify</a></li>"
        html += "</ul>"
        return html
    except Exception as e:
        app.logger.exception("Admin index error")
        return "Admin error", 500


# ------------------------------------------------------------------
# ADMIN: verify & edit a single rule
# ------------------------------------------------------------------
@app.route("/admin/verify/<int:rule_id>", methods=["GET", "POST"])
@require_admin
def admin_verify(rule_id):
    rule = SchemeRule.query.get_or_404(rule_id)
    if request.method == "POST":
        # admin submitted edited JSON (form or raw)
        raw = request.form.get("rule_json") or request.get_data(as_text=True)
        if not raw:
            return "No rule_json submitted", 400
        try:
            parsed = json.loads(raw)
        except Exception as e:
            return f"Invalid JSON: {e}", 400
        rule.rule_json = parsed
        rule.verified = True
        db.session.commit()
        return redirect(url_for("admin_index"))
    # GET -> render verification page
    template_path = os.path.join(app.root_path, "templates", "admin_verify.html")
    if os.path.exists(template_path):
        return render_template("admin_verify.html", rule=rule)
    # Minimal HTML fallback
    return f"""
    <h2>Verify Rule #{rule.id} (scheme {rule.scheme_id})</h2>
    <h3>Original snippet</h3>
    <pre>{rule.snippet or ''}</pre>
    <h3>Current JSON</h3>
    <form method="post">
      <textarea name="rule_json" style="width:100%;min-height:300px;">{json.dumps(rule.rule_json or {}, indent=2)}</textarea>
      <br><button type="submit">Save & Verify</button>
    </form>
    """


# ------------------------------------------------------------------
# ADMIN API: update rule (JSON)
# ------------------------------------------------------------------
@app.route("/admin/update_rule", methods=["POST"])
@require_admin
def admin_update_rule():
    try:
        payload = request.get_json(force=True)
        rule_id = payload.get("rule_id")
        new_rule = payload.get("rule_json")
        if not rule_id or new_rule is None:
            return jsonify({"error": "rule_id and rule_json required"}), 400
        rule = SchemeRule.query.get_or_404(rule_id)
        rule.rule_json = new_rule
        rule.verified = True
        # optional: update parser_confidence
        if "parser_confidence" in payload:
            try:
                rule.parser_confidence = float(payload["parser_confidence"])
            except Exception:
                pass
        db.session.commit()
        return jsonify({"ok": True, "rule_id": rule.id}), 200
    except Exception as e:
        app.logger.exception("admin_update_rule failed")
        return jsonify({"error": "update failed", "detail": str(e)}), 500


# ------------------------------------------------------------------
# Error handlers (optional niceties)
# ------------------------------------------------------------------
@app.errorhandler(404)
def not_found(e):
    return jsonify({"error": "Not found"}), 404


@app.errorhandler(500)
def internal_err(e):
    tb = traceback.format_exc()
    app.logger.error("Internal error: %s", tb)
    return jsonify({"error": "Internal server error"}), 500
import sqlite3
import os
import json

SAMPLE_SCHEMES = [
    {
        'title': 'Young Farmers Support Scheme',
        'description': 'Support scheme for farmers aged between 18 and 35 with annual income below 500000',
        'state': 'Karnataka',
        'source_url': 'https://gov.example/young-farmers'
    },
    {
        'title': 'Senior Citizens Health Aid',
        'description': 'Health aid for citizens above 60 years with low income',
        'state': 'Maharashtra',
        'source_url': 'https://gov.example/senior-health'
    },
    {
        'title': 'Women Entrepreneur Grant',
        'description': 'Grant for women entrepreneurs with household income below 800000',
        'state': 'Karnataka',
        'source_url': 'https://gov.example/women-entrepreneur'
    }
]

# sample rule JSONs that our admin UI can edit later
SAMPLE_RULES = {
    1: json.dumps({
        'all':[{'field':'age','op':'>=','value':18},{'field':'age','op':'<=','value':35},{'field':'occupation','op':'in','value':['farmer','agricultural worker']},{'field':'income','op':'<','value':500000}],
    }),
    2: json.dumps({
        'all':[{'field':'age','op':'>=','value':60},{'field':'income','op':'<','value':400000}],
    }),
    3: json.dumps({
        'all':[{'field':'gender','op':'==','value':'female'},{'field':'income','op':'<','value':800000}],
    })
}


def ensure_sample_data(db_path):
    if os.path.exists(db_path):
        # assume data exists
        conn = sqlite3.connect(db_path)
        cur = conn.cursor()
        cur.execute('SELECT COUNT(*) FROM schemes')
        cnt = cur.fetchone()[0]
        if cnt > 0:
            conn.close()
            return
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    # insert schemes
    for s in SAMPLE_SCHEMES:
        cur.execute('INSERT INTO schemes (title, description, state, source_url) VALUES (?,?,?,?)', (s['title'], s['description'], s['state'], s['source_url']))
    conn.commit()
    # insert rules
    for scheme_id, rule_json in SAMPLE_RULES.items():
        cur.execute('INSERT INTO scheme_rules (scheme_id, rule_json, snippet, parser_confidence) VALUES (?,?,?,?)', (scheme_id, rule_json, 'Sample extracted snippet for scheme '+str(scheme_id), 0.9))
    conn.commit()
    conn.close()
